// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: location.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/stephenirven/go-postgis/geo"
)

const createLocation = `-- name: CreateLocation :one
INSERT INTO location (
  full_name, geo
) VALUES (
  $1, $2::geometry
)
RETURNING id, organisation_id, user_id, full_name, line1, line2, city, county, country_code, geo, created_at
`

type CreateLocationParams struct {
	FullName sql.NullString  `json:"full_name"`
	Geo      geo.GISGeometry `json:"geo"`
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (Location, error) {
	row := q.db.QueryRowContext(ctx, createLocation, arg.FullName, arg.Geo)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.UserID,
		&i.FullName,
		&i.Line1,
		&i.Line2,
		&i.City,
		&i.County,
		&i.CountryCode,
		&i.Geo,
		&i.CreatedAt,
	)
	return i, err
}

const deleteLocation = `-- name: DeleteLocation :exec
DELETE FROM location
WHERE id = $1
`

func (q *Queries) DeleteLocation(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteLocation, id)
	return err
}

const getLocation = `-- name: GetLocation :one
SELECT 
		id, organisation_id, user_id, full_name,
		line1
		line2,
		city,
		county,
		country_code,
		geo::geometry,
		created_at
FROM location
WHERE id = $1 LIMIT 1
`

type GetLocationRow struct {
	ID             int64           `json:"id"`
	OrganisationID sql.NullInt64   `json:"organisation_id"`
	UserID         sql.NullInt64   `json:"user_id"`
	FullName       sql.NullString  `json:"full_name"`
	Line2          sql.NullString  `json:"line2"`
	City           sql.NullString  `json:"city"`
	County         sql.NullString  `json:"county"`
	CountryCode    sql.NullString  `json:"country_code"`
	Geo            geo.GISGeometry `json:"geo"`
	CreatedAt      time.Time       `json:"created_at"`
}

func (q *Queries) GetLocation(ctx context.Context, id int64) (GetLocationRow, error) {
	row := q.db.QueryRowContext(ctx, getLocation, id)
	var i GetLocationRow
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.UserID,
		&i.FullName,
		&i.Line2,
		&i.City,
		&i.County,
		&i.CountryCode,
		&i.Geo,
		&i.CreatedAt,
	)
	return i, err
}

const getLocationForUpdate = `-- name: GetLocationForUpdate :one
SELECT 
		id, organisation_id, user_id, full_name,
		line1
		line2,
		city,
		county,
		country_code,
		geo::geometry,
		created_at
FROM location
WHERE id = $1 LIMIT 1
FOR NO KEY UPDATE
`

type GetLocationForUpdateRow struct {
	ID             int64           `json:"id"`
	OrganisationID sql.NullInt64   `json:"organisation_id"`
	UserID         sql.NullInt64   `json:"user_id"`
	FullName       sql.NullString  `json:"full_name"`
	Line2          sql.NullString  `json:"line2"`
	City           sql.NullString  `json:"city"`
	County         sql.NullString  `json:"county"`
	CountryCode    sql.NullString  `json:"country_code"`
	Geo            geo.GISGeometry `json:"geo"`
	CreatedAt      time.Time       `json:"created_at"`
}

func (q *Queries) GetLocationForUpdate(ctx context.Context, id int64) (GetLocationForUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, getLocationForUpdate, id)
	var i GetLocationForUpdateRow
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.UserID,
		&i.FullName,
		&i.Line2,
		&i.City,
		&i.County,
		&i.CountryCode,
		&i.Geo,
		&i.CreatedAt,
	)
	return i, err
}

const getLocations = `-- name: GetLocations :many
SELECT id, organisation_id, user_id, full_name,
		line1
		line2,
		city,
		county,
		country_code,
		geo::geometry,
		created_at
FROM location
`

type GetLocationsRow struct {
	ID             int64           `json:"id"`
	OrganisationID sql.NullInt64   `json:"organisation_id"`
	UserID         sql.NullInt64   `json:"user_id"`
	FullName       sql.NullString  `json:"full_name"`
	Line2          sql.NullString  `json:"line2"`
	City           sql.NullString  `json:"city"`
	County         sql.NullString  `json:"county"`
	CountryCode    sql.NullString  `json:"country_code"`
	Geo            geo.GISGeometry `json:"geo"`
	CreatedAt      time.Time       `json:"created_at"`
}

func (q *Queries) GetLocations(ctx context.Context) ([]GetLocationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLocations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLocationsRow
	for rows.Next() {
		var i GetLocationsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganisationID,
			&i.UserID,
			&i.FullName,
			&i.Line2,
			&i.City,
			&i.County,
			&i.CountryCode,
			&i.Geo,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLocationsWithinDistance = `-- name: ListLocationsWithinDistance :many
SELECT 
		id, organisation_id, user_id, full_name,
		line1
		line2,
		city,
		county,
		country_code,
		geo::geometry,
		created_at
FROM location
WHERE
  ST_DWithin(
    geo::geometry,    
    $3::geometry,
    $4::INT)
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListLocationsWithinDistanceParams struct {
	Limit    int64           `json:"limit"`
	Offset   int64           `json:"offset"`
	Location geo.GISGeometry `json:"location"`
	Range    int32           `json:"range"`
}

type ListLocationsWithinDistanceRow struct {
	ID             int64           `json:"id"`
	OrganisationID sql.NullInt64   `json:"organisation_id"`
	UserID         sql.NullInt64   `json:"user_id"`
	FullName       sql.NullString  `json:"full_name"`
	Line2          sql.NullString  `json:"line2"`
	City           sql.NullString  `json:"city"`
	County         sql.NullString  `json:"county"`
	CountryCode    sql.NullString  `json:"country_code"`
	Geo            geo.GISGeometry `json:"geo"`
	CreatedAt      time.Time       `json:"created_at"`
}

func (q *Queries) ListLocationsWithinDistance(ctx context.Context, arg ListLocationsWithinDistanceParams) ([]ListLocationsWithinDistanceRow, error) {
	rows, err := q.db.QueryContext(ctx, listLocationsWithinDistance,
		arg.Limit,
		arg.Offset,
		arg.Location,
		arg.Range,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLocationsWithinDistanceRow
	for rows.Next() {
		var i ListLocationsWithinDistanceRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganisationID,
			&i.UserID,
			&i.FullName,
			&i.Line2,
			&i.City,
			&i.County,
			&i.CountryCode,
			&i.Geo,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
